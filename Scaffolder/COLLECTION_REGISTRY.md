# Collection Registry System

## Overview

The collection registry system provides a centralized, explicit way to manage all CRUD collections in the application. It replaces the previous complex glob-based auto-discovery system with a simpler, more maintainable approach.

## Architecture

### Key Components

1. **Registry File** (`layers/crud/registry/collections.ts`)
   - Central registry of all collections
   - Uses Nuxt's `#imports` for dynamic loading
   - Auto-generated and maintained by tooling

2. **useCollections Composable** (`layers/crud/composables/useCollections.ts`)
   - Simplified from 138 lines to ~65 lines (53% reduction)
   - Provides synchronous access to collection configs
   - Creates reactive state for each collection

3. **Generate Script** (`scripts/generate-registry.mjs`)
   - Scans for all collection composables
   - Generates the registry file automatically
   - Maintains consistency across the codebase

## How It Works

### 1. Registry Generation

The registry is generated by scanning the file system for collection composables:

```javascript
// Glob pattern to find all collections
'layers/*/collections/*/app/composables/use*.ts'

// Generates entries like:
{
  posProducts: () => import('#imports').then(m => m.usePosProducts),
  translationsUi: () => import('#imports').then(m => m.useTranslationsUi),
  // ... etc
}
```

### 2. Config Loading

Configs are loaded synchronously at initialization:

```javascript
// Direct imports from Nuxt's auto-imports
import {
  posProductsConfig,
  posEventsConfig,
  translationsUiConfig,
  // ... etc
} from '#imports'

// Synchronous access in useCollections
const getConfig = (name: string) => {
  return configsMap[name]
}
```

### 3. Module Resolution

The system leverages Nuxt's `#imports` alias:
- All composables are auto-imported by Nuxt
- Registry uses `#imports` for clean dynamic imports
- No path resolution issues or relative import complexity

## Collection Types

### Standard Collections (POS Pattern)

Most collections follow the POS pattern with full config exports:

```javascript
// Example: usePosProducts.ts
export const posProductsConfig = {
  name: 'posProducts',
  apiPath: 'pos-products',
  componentName: 'PosProductsForm',
  schema: posProductSchema,
  defaultValues: { ... },
  columns: [ ... ]
}
```

### Special Cases

Some collections like `teamTranslations` don't export configs:
- These are handled gracefully
- `getConfig()` returns `undefined` for these
- They may use different patterns for data management

## Adding New Collections

### Automatic (via Scaffolder)

When you generate a new collection:

```bash
node Scaffolder/scripts/generate-collection.mjs pos newcollection --fields-file=schema.json
```

The scaffolder automatically:
1. Creates all collection files
2. Updates the registry with the new entry
3. Exports the config in the standard format

### Manual Registry Update

If needed, you can manually regenerate the registry:

```bash
node scripts/generate-registry.mjs
```

This will:
- Scan all collections
- Regenerate the registry file
- Preserve the same structure

## Benefits of the New System

### 1. Simplicity
- **Before**: 138 lines of complex glob patterns and dynamic loading
- **After**: 65 lines of straightforward imports and mappings
- **Reduction**: 53% less code to maintain

### 2. Performance
- Configs loaded synchronously (no async in critical path)
- Leverages Nuxt's optimized auto-import system
- Better tree-shaking and bundle optimization

### 3. Type Safety
- Explicit `CollectionName` type from registry
- Full TypeScript support for configs
- Better IDE autocomplete and error detection

### 4. Debugging
- Clear import paths in registry
- Easy to trace which collections are loaded
- No hidden magic or implicit discovery

### 5. Maintainability
- New collections automatically added by scaffolder
- Registry can be regenerated anytime
- Clear separation of concerns

## Migration Notes

### What Changed

1. **Discovery Method**
   - Old: Runtime glob pattern matching
   - New: Explicit registry with build-time generation

2. **Import Strategy**
   - Old: Direct file imports with `~/layers/...` paths
   - New: Nuxt `#imports` for cleaner module resolution

3. **Config Access**
   - Old: Async config loading on demand
   - New: Synchronous access to pre-loaded configs

### Backward Compatibility

The API remains the same for consumers:
- `useCollections()` returns the same interface
- `getConfig(name)` works as before (now synchronous)
- `componentMap` still provides component mappings
- Collection state management unchanged

## File Structure

```
layers/
├── crud/
│   ├── composables/
│   │   └── useCollections.ts      # Main composable (simplified)
│   └── registry/
│       └── collections.ts          # Auto-generated registry
├── pos/
│   └── collections/
│       ├── products/
│       ├── events/
│       └── ...                     # Standard collections
└── translations/
    └── collections/
        └── ui/                     # Special case collection

scripts/
└── generate-registry.mjs           # Registry generator

Scaffolder/
└── scripts/
    └── generate-collection.mjs     # Updates registry on new collections
```

## Troubleshooting

### Collection Not Found

If a collection isn't recognized:
1. Check it follows the naming pattern: `use[Layer][Collection].ts`
2. Ensure it's in the correct path: `layers/[layer]/collections/[name]/app/composables/`
3. Run `node scripts/generate-registry.mjs` to regenerate

### Config Returns Undefined

Some collections (like `teamTranslations`) don't have configs:
- This is expected for special-case collections
- Check if the collection exports a `[name]Config` object
- Standard collections should always have configs

### API Path Issues

If the wrong API path is used:
- Check the config's `apiPath` property
- Ensure the config is properly exported from the composable
- Verify the config is imported in `useCollections.ts`

## Future Improvements

Potential enhancements to consider:

1. **Dynamic Config Loading**: Generate the config imports automatically
2. **Config Validation**: Runtime validation of config structure
3. **Hot Module Replacement**: Better HMR support for registry changes
4. **Config Inheritance**: Base configs for common patterns

---

*Last Updated: September 2024*
*System Version: 2.0*
*Code Reduction: 53% (138 → 65 lines)*