# Collection Registry Refactor Briefing

## Overview

This document outlines the plan to refactor the current complex glob-based collection discovery system into a simpler, more maintainable registry-based approach while preserving the scaffolder's auto-generation capabilities.

## Current Problems

### 1. **Over-Complex Auto-Discovery**
- Uses heavy `import.meta.glob()` patterns with complex path parsing
- 100+ lines of code for simple collection management
- Difficult to debug and maintain
- Poor TypeScript integration

### 2. **Runtime Complexity**
```typescript
// Current: Heavy runtime processing
const modules = import.meta.glob('../../*/collections/**/app/composables/use*.ts', { eager: true })
const collectionConfigs = Object.entries(modules)
  .map(moduleToConfig)
  .filter(Boolean)
  .reduce((acc, config) => ({ ...acc, ...config }), {})
```

### 3. **Type Safety Issues**
- Dynamic imports lose TypeScript benefits
- No compile-time collection name validation
- Hard to track collection dependencies

## Proposed Solution: Simple Registry Pattern

### Core Concept
Replace complex auto-discovery with an explicit registry file that the scaffolder maintains automatically.

## Implementation Plan

### Phase 1: Create Registry Infrastructure

#### 1.1 Create Registry File
**File**: `layers/crud/registry/collections.ts`

```typescript
export const collectionRegistry = {
  // POS Collections
  posProducts: () => import('~/layers/pos/collections/products/app/composables/usePosProducts'),
  posEvents: () => import('~/layers/pos/collections/events/app/composables/usePosEvents'),
  posOrders: () => import('~/layers/pos/collections/orders/app/composables/usePosOrders'),
  posOrderProducts: () => import('~/layers/pos/collections/orderproducts/app/composables/usePosOrderProducts'),
  posPrinters: () => import('~/layers/pos/collections/printers/app/composables/usePosPrinters'),
  posPrintQueues: () => import('~/layers/pos/collections/printqueues/app/composables/usePosPrintQueues'),
  
  // Translation Collections
  translationsUi: () => import('~/layers/translations/collections/ui/app/composables/useTranslationsUi'),
  
  // Future collections will be added here automatically by scaffolder
} as const

export type CollectionName = keyof typeof collectionRegistry

// Component mapping for dynamic form loading
export const componentMap = {
  posProducts: 'PosProductsForm',
  posEvents: 'PosEventsForm', 
  posOrders: 'PosOrdersForm',
  posOrderProducts: 'PosOrderProductsForm',
  posPrinters: 'PosPrintersForm',
  posPrintQueues: 'PosPrintQueuesForm',
  translationsUi: 'TranslationsUiForm',
  // Auto-generated by scaffolder
} as const
```

#### 1.2 Simplified useCollections Composable
**File**: `layers/crud/composables/useCollections.ts`

```typescript
import { collectionRegistry, componentMap, type CollectionName } from '~/layers/crud/registry/collections'

/**
 * Simplified collection management composable
 * No more complex glob imports or runtime path parsing
 */
export default function useCollections() {
  // Create reactive states for each registered collection
  const collections = Object.keys(collectionRegistry).reduce((acc, name) => {
    acc[name as CollectionName] = useState(name, () => [])
    return acc
  }, {} as Record<CollectionName, Ref<any[]>>)

  // Async config loader - only loads when needed
  const getConfig = async (name: CollectionName) => {
    const loader = collectionRegistry[name]
    if (!loader) {
      console.warn(`Collection "${name}" not found in registry`)
      return undefined
    }
    
    try {
      const module = await loader()
      const configKey = Object.keys(module).find(key => key.endsWith('Config'))
      return configKey ? module[configKey] : undefined
    } catch (error) {
      console.error(`Failed to load collection config for "${name}":`, error)
      return undefined
    }
  }

  return {
    // Individual collection states
    ...collections,
    
    // Utility functions
    componentMap,
    getConfig,
    collectionNames: Object.keys(collectionRegistry) as CollectionName[],
    
    // Registry for inspection
    registry: collectionRegistry
  }
}
```

### Phase 2: Update Scaffolder

#### 2.1 Registry Update Function
**File**: `Scaffolder/utils/registry.mjs`

```javascript
import fs from 'fs/promises'
import path from 'path'
import { colors } from './colors.mjs'

/**
 * Updates the collection registry with a new collection
 */
export async function updateCollectionRegistry(layer, collection, collectionKey, componentName) {
  const registryPath = path.join(process.cwd(), 'layers/crud/registry/collections.ts')
  
  try {
    // Read current registry file
    let content = await fs.readFile(registryPath, 'utf8')
    
    // Check if collection already exists
    if (content.includes(`${collectionKey}:`)) {
      console.log(`${colors.yellow}⚠${colors.reset} Collection "${collectionKey}" already exists in registry`)
      return
    }
    
    // Update collectionRegistry
    const registryInsertPoint = content.lastIndexOf('} as const')
    const newRegistryEntry = `  ${collectionKey}: () => import('~/layers/${layer}/collections/${collection}/app/composables/use${componentName}'),\n`
    content = content.slice(0, registryInsertPoint) + newRegistryEntry + content.slice(registryInsertPoint)
    
    // Update componentMap
    const componentMapInsertPoint = content.lastIndexOf('} as const', content.lastIndexOf('componentMap'))
    const newComponentEntry = `  ${collectionKey}: '${componentName}Form',\n`
    content = content.slice(0, componentMapInsertPoint) + newComponentEntry + content.slice(componentMapInsertPoint)
    
    // Write updated content
    await fs.writeFile(registryPath, content)
    
    console.log(`${colors.green}✓${colors.reset} Updated collection registry with "${collectionKey}"`)
    
  } catch (error) {
    console.error(`${colors.red}✗${colors.reset} Failed to update collection registry:`, error)
    throw error
  }
}

/**
 * Validates that registry file exists and creates it if missing
 */
export async function ensureRegistryExists() {
  const registryPath = path.join(process.cwd(), 'layers/crud/registry/collections.ts')
  const registryDir = path.dirname(registryPath)
  
  try {
    await fs.access(registryPath)
  } catch {
    // Create directory if it doesn't exist
    await fs.mkdir(registryDir, { recursive: true })
    
    // Create initial registry file
    const initialContent = `export const collectionRegistry = {
  // Collections will be registered here automatically by the scaffolder
} as const

export type CollectionName = keyof typeof collectionRegistry

export const componentMap = {
  // Component mappings will be added here automatically by the scaffolder
} as const
`
    
    await fs.writeFile(registryPath, initialContent)
    console.log(`${colors.green}✓${colors.reset} Created initial collection registry`)
  }
}
```

#### 2.2 Update Generation Script
**File**: `Scaffolder/scripts/generate-collection.mjs`

```javascript
// Add import at the top
import { updateCollectionRegistry, ensureRegistryExists } from '../utils/registry.mjs'

// In the main generateCollection function, after successful generation:
async function generateCollection(layer, name, options = {}) {
  // ... existing generation code ...
  
  try {
    // Ensure registry exists
    await ensureRegistryExists()
    
    // ... existing file generation ...
    
    // Update registry after successful generation
    await updateCollectionRegistry(layer, cases.plural, collectionKey, cases.pascalCase)
    
    console.log(`${colors.green}✅ Collection "${collectionKey}" generated successfully!${colors.reset}`)
    console.log(`\n${colors.blue}Next steps:${colors.reset}`)
    console.log(`1. Export schema in server/database/schema/index.ts`)
    console.log(`2. Run database migrations`)
    console.log(`3. Restart Nuxt dev server`)
    
  } catch (error) {
    // ... existing error handling ...
  }
}
```

### Phase 3: Migration Strategy

#### 3.1 Create Migration Script
**File**: `scripts/migrate-to-registry.mjs`

```javascript
#!/usr/bin/env node

/**
 * Migration script to move from glob-based to registry-based collection discovery
 */

import fs from 'fs/promises'
import path from 'path'
import { glob } from 'glob'

async function migrateToRegistry() {
  console.log('🔄 Migrating to registry-based collection discovery...\n')
  
  // 1. Find all existing collections
  const composableFiles = await glob('layers/*/collections/*/app/composables/use*.ts')
  
  const collections = []
  
  for (const file of composableFiles) {
    const parts = file.split('/')
    const layer = parts[1]
    const collection = parts[3]
    const composableName = path.basename(file, '.ts').replace('use', '')
    
    const collectionKey = `${layer}${composableName}`.replace(/([A-Z])/g, (match, p1, offset) => {
      return offset === 0 ? p1.toLowerCase() : p1
    })
    
    collections.push({
      key: collectionKey,
      layer,
      collection,
      composableName,
      importPath: `~/layers/${layer}/collections/${collection}/app/composables/use${composableName}`
    })
  }
  
  // 2. Generate registry content
  const registryEntries = collections
    .map(c => `  ${c.key}: () => import('${c.importPath}'),`)
    .join('\n')
    
  const componentEntries = collections
    .map(c => `  ${c.key}: '${c.composableName}Form',`)
    .join('\n')
  
  const registryContent = `export const collectionRegistry = {
${registryEntries}
} as const

export type CollectionName = keyof typeof collectionRegistry

export const componentMap = {
${componentEntries}
} as const
`

  // 3. Write registry file
  const registryDir = path.join(process.cwd(), 'layers/crud/registry')
  await fs.mkdir(registryDir, { recursive: true })
  await fs.writeFile(path.join(registryDir, 'collections.ts'), registryContent)
  
  console.log(`✅ Created registry with ${collections.length} collections`)
  console.log('\n📝 Found collections:')
  collections.forEach(c => console.log(`   - ${c.key} (${c.layer}/${c.collection})`))
  
  console.log('\n🎯 Next steps:')
  console.log('1. Update layers/crud/composables/useCollections.ts')
  console.log('2. Remove old glob-based logic')
  console.log('3. Test that all collections still work')
  console.log('4. Update scaffolder to use new registry')
}

migrateToRegistry().catch(console.error)
```

### Phase 4: Testing & Validation

#### 4.1 Validation Checklist
- [ ] All existing collections appear in registry
- [ ] Dynamic form loading still works
- [ ] Scaffolder successfully adds new collections
- [ ] TypeScript types are properly inferred
- [ ] No runtime errors in collection discovery
- [ ] Performance improvement is measurable

#### 4.2 Test Script
**File**: `scripts/test-collections.mjs`

```javascript
/**
 * Test script to validate collection registry functionality
 */

async function testCollections() {
  console.log('🧪 Testing collection registry...\n')
  
  // Test 1: Load registry
  try {
    const { collectionRegistry, componentMap } = await import('../layers/crud/registry/collections.ts')
    console.log('✅ Registry loaded successfully')
    console.log(`   Found ${Object.keys(collectionRegistry).length} collections`)
    console.log(`   Found ${Object.keys(componentMap).length} component mappings`)
  } catch (error) {
    console.error('❌ Failed to load registry:', error)
    return
  }
  
  // Test 2: Validate all collections can be loaded
  const { collectionRegistry } = await import('../layers/crud/registry/collections.ts')
  
  for (const [name, loader] of Object.entries(collectionRegistry)) {
    try {
      const module = await loader()
      const configKey = Object.keys(module).find(key => key.endsWith('Config'))
      if (configKey) {
        console.log(`✅ ${name}: Config loaded`)
      } else {
        console.log(`⚠️  ${name}: No config found`)
      }
    } catch (error) {
      console.error(`❌ ${name}: Failed to load -`, error.message)
    }
  }
  
  console.log('\n🎯 Registry test complete!')
}

testCollections().catch(console.error)
```

## Benefits of This Approach

### ✅ **Simplicity**
- Clear, explicit collection registration
- No complex runtime path parsing
- Easy to understand and maintain

### ✅ **Performance**
- Lazy loading of collection configs
- No heavy glob processing at runtime
- Better tree-shaking support

### ✅ **Type Safety**
- Full TypeScript support
- Compile-time collection name validation
- Better IDE autocompletion

### ✅ **Scaffolder Integration**
- Simple registry updates
- No need to modify complex glob patterns
- Automatic component mapping

### ✅ **Debugging**
- Clear import paths
- Explicit registration process
- Easy to trace collection loading

## Migration Timeline

### Week 1: Infrastructure
- Create registry system
- Update useCollections composable
- Create migration script

### Week 2: Scaffolder Integration
- Update scaffolder to use registry
- Test generation of new collections
- Validate existing collections work

### Week 3: Testing & Cleanup
- Run comprehensive tests
- Remove old glob-based code
- Update documentation

## Rollback Plan

If issues arise, rollback is simple:
1. Revert `useCollections.ts` to glob-based version
2. Remove registry files
3. Continue using existing system

The registry approach is additive and doesn't break existing functionality during transition.

## Success Metrics

- [ ] Reduction in `useCollections.ts` complexity (target: <50 lines)
- [ ] Improved TypeScript coverage
- [ ] Faster collection loading times
- [ ] Easier debugging and maintenance
- [ ] Successful scaffolder integration

## Implementation Commands

### Step 1: Create Migration Script
```bash
# Make migration script executable
chmod +x scripts/migrate-to-registry.mjs

# Run migration to create initial registry
node scripts/migrate-to-registry.mjs
```

### Step 2: Update Scaffolder
```bash
# Create scaffolder utilities
mkdir -p Scaffolder/utils
# Add the registry.mjs utility file

# Update generate-collection.mjs to use registry
```

### Step 3: Test Everything
```bash
# Run collection tests
node scripts/test-collections.mjs

# Test scaffolder with new collection
node Scaffolder/scripts/generate-collection.mjs test items --fields-file=example.json
```

### Step 4: Clean Up
```bash
# Remove old complex useCollections.ts logic
# Update imports in existing files
# Remove unused glob-based code
```

---

**Status**: 🟡 Planning Phase  
**Assignee**: Development Team  
**Timeline**: 3 weeks  
**Priority**: High (Technical Debt)  
**Impact**: Major simplification of collection system