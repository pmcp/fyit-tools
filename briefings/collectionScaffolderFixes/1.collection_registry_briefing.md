# Collection Registry Migration - Implementation Briefing

## Objective
Replace the complex glob-based collection discovery system with a simple, explicit registry file that maintains the same functionality with less complexity.

## Current State
- **100+ lines** of complex glob pattern matching in `useCollections.ts`
- **13 collections** across 2 layers (pos and translations)
- Collections already contain their own `componentName` in configs
- Scaffolder already updates schema exports

## Target State
- **~30 lines** in `useCollections.ts`
- Explicit registry file listing all collections
- Scaffolder automatically maintains the registry
- Better TypeScript support and debugging

## Implementation Plan (2 Hours Total)

### Step 1: Generate Initial Registry (30 minutes)

Create and run `scripts/generate-registry.mjs`:

```javascript
#!/usr/bin/env node
import { glob } from 'glob'
import fs from 'fs/promises'
import path from 'path'

async function generateRegistry() {
  console.log('🔍 Scanning for collections...')
  
  const files = await glob('layers/*/collections/*/app/composables/use*.ts')
  const entries = []
  
  for (const file of files) {
    const parts = file.split('/')
    const layer = parts[1]
    const collection = parts[3]
    const fileName = path.basename(file, '.ts')
    const composableName = fileName.replace('use', '')
    
    // Create collection key (e.g., posProducts, translationsUi)
    // Handle PascalCase to camelCase conversion
    const collectionKey = composableName.charAt(0).toLowerCase() + composableName.slice(1)
    
    entries.push({
      key: collectionKey,
      import: `~/layers/${layer}/collections/${collection}/app/composables/${fileName}`
    })
    
    console.log(`  ✓ Found: ${collectionKey}`)
  }
  
  // Generate registry content
  const registryContent = `// Auto-generated collection registry
// This file is maintained by the scaffolder - do not edit manually

export const collectionRegistry = {
${entries.map(e => `  ${e.key}: () => import('${e.import}'),`).join('\n')}
} as const

export type CollectionName = keyof typeof collectionRegistry
`
  
  // Create registry directory and file
  await fs.mkdir('layers/crud/registry', { recursive: true })
  await fs.writeFile('layers/crud/registry/collections.ts', registryContent)
  
  console.log(`\n✅ Generated registry with ${entries.length} collections`)
}

generateRegistry().catch(console.error)
```

**Run it:**
```bash
node scripts/generate-registry.mjs
```

### Step 2: Simplify useCollections (20 minutes)

Replace `layers/crud/composables/useCollections.ts`:

```typescript
import { collectionRegistry, type CollectionName } from '~/layers/crud/registry/collections'

/**
 * Simplified collection management using explicit registry
 */
export default function useCollections() {
  // Storage for loaded configs
  const loadedConfigs: Record<string, any> = {}
  const componentMap = reactive<Record<string, string>>({})
  
  // Create reactive state for each collection
  const collections = Object.keys(collectionRegistry).reduce((acc, name) => {
    acc[name as CollectionName] = useState(name, () => [])
    return acc
  }, {} as Record<CollectionName, Ref<any[]>>)
  
  // Load config on demand
  const getConfig = async (name: string) => {
    if (loadedConfigs[name]) {
      return loadedConfigs[name]
    }
    
    const loader = collectionRegistry[name as CollectionName]
    if (!loader) {
      console.warn(`Collection "${name}" not found`)
      return undefined
    }
    
    try {
      const module = await loader()
      // Find the config export (ends with 'Config')
      const configKey = Object.keys(module).find(key => key.endsWith('Config'))
      const config = configKey ? module[configKey] : undefined
      
      if (config) {
        loadedConfigs[name] = config
        // Update component map if config has componentName
        if (config.componentName) {
          componentMap[name] = config.componentName
        }
      }
      
      return config
    } catch (error) {
      console.error(`Failed to load config for "${name}":`, error)
      return undefined
    }
  }
  
  return {
    ...collections,
    componentMap,
    getConfig,
    configs: loadedConfigs
  }
}
```

### Step 3: Update Scaffolder (10 minutes)

Add to `Scaffolder/scripts/generate-collection.mjs` after successful generation:

```javascript
// After all files are generated successfully
async function updateRegistry(layer, collection, collectionKey, componentName) {
  const registryPath = path.join(process.cwd(), 'layers/crud/registry/collections.ts')
  
  try {
    let content = await fs.readFile(registryPath, 'utf8')
    
    // Check if already exists
    if (content.includes(`${collectionKey}:`)) {
      console.log(`⚠️  Collection "${collectionKey}" already in registry`)
      return
    }
    
    // Add new entry before the closing brace
    const importPath = `~/layers/${layer}/collections/${collection}/app/composables/use${componentName}`
    const newEntry = `  ${collectionKey}: () => import('${importPath}'),`
    
    content = content.replace(
      '} as const',
      `${newEntry}\n} as const`
    )
    
    await fs.writeFile(registryPath, content)
    console.log(`✓ Added "${collectionKey}" to registry`)
  } catch (error) {
    console.error('Failed to update registry:', error)
    // Don't fail the entire generation if registry update fails
  }
}

// Call it in the main generation flow
await updateRegistry(layer, pluralName, collectionKey, pascalCase)
```

### Step 4: Test (30 minutes)

**Test Checklist:**
- [ ] Run `node scripts/generate-registry.mjs`
- [ ] Verify all 13 collections appear in registry
- [ ] Restart Nuxt dev server
- [ ] Open any CRUD form - verify it loads
- [ ] Create/update/delete an item
- [ ] Generate a new collection with scaffolder
- [ ] Verify new collection appears in registry
- [ ] Verify new collection CRUD works

## Files to Modify

1. **Create:** `scripts/generate-registry.mjs` (new file)
2. **Create:** `layers/crud/registry/collections.ts` (generated)
3. **Replace:** `layers/crud/composables/useCollections.ts`
4. **Update:** `Scaffolder/scripts/generate-collection.mjs` (add registry update)

## What We're NOT Doing

- ❌ No gradual migration or feature flags
- ❌ No complex validation steps
- ❌ No rollback mechanisms (just use git)
- ❌ No handling of theoretical edge cases
- ❌ No separate componentMap (configs already have it)

## Expected Outcome

- `useCollections.ts` reduced from 100+ lines to ~30 lines
- Explicit, debuggable collection imports
- Full TypeScript support with `CollectionName` type
- Scaffolder maintains registry automatically
- Same functionality, less complexity

## Migration Commands

```bash
# 1. Generate the registry
node scripts/generate-registry.mjs

# 2. Restart dev server
npm run dev

# 3. Test existing collections work

# 4. Test scaffolder with new collection
node Scaffolder/scripts/generate-collection.mjs test items --fields-file=example.json

# 5. Verify new collection in registry
cat layers/crud/registry/collections.ts | grep testItems
```

## Success Criteria

✅ All existing collections work without changes  
✅ New collections auto-register when scaffolded  
✅ TypeScript provides proper autocompletion  
✅ Easier to debug (explicit imports)  
✅ Less code to maintain

## Timeline

- **Hour 1:** Steps 1-3 (Generate registry, update composable, update scaffolder)
- **Hour 2:** Step 4 (Testing and fixing any issues)
- **Done:** Commit and move on

## Notes on Existing Collections

Based on the codebase scan, here are the collections that should appear in your registry:

### POS Layer (11 collections)
- `posProducts` - Product management
- `posEvents` - Event management
- `posOrders` - Order management
- `posOrderProducts` - Order products junction
- `posCategories` - Category management
- `posClients` - Client management
- `posLocations` - Location management
- `posPrinters` - Printer management
- `posPrintQueues` - Print queue management
- `posPrinterLocations` - Printer locations junction
- `posSystemLogs` - System logging

### Translations Layer (1-2 collections)
- `translationsUi` - UI translations
- `teamTranslations` - Team translations (if exists)

## Common Issues & Solutions

### Issue: Registry not found after generation
**Solution:** Make sure the path `layers/crud/registry/` exists. The script creates it, but verify permissions.

### Issue: Collections not loading after migration
**Solution:** Check that the import paths in the registry match the actual file locations. The pattern should be:
```
~/layers/[layer]/collections/[collection]/app/composables/use[ComponentName]
```

### Issue: TypeScript errors about CollectionName
**Solution:** Restart your TypeScript language server in your IDE after generating the registry.

### Issue: Scaffolder not updating registry
**Solution:** Ensure the `updateRegistry` function is called AFTER all files are successfully generated, not before.

## Code Snippets for Quick Reference

### Check what collections were discovered:
```javascript
// Quick debug script
import { collectionRegistry } from './layers/crud/registry/collections.ts'
console.log('Registered collections:', Object.keys(collectionRegistry))
```

### Manually add a missing collection:
```typescript
// In layers/crud/registry/collections.ts, add:
missingCollection: () => import('~/layers/[layer]/collections/[name]/app/composables/use[Name]'),
```

### Test a specific collection loads:
```javascript
// In browser console or test file
const { getConfig } = useCollections()
const config = await getConfig('posProducts')
console.log('Config loaded:', config)
```

---

**Status:** Ready for Implementation  
**Complexity:** Low  
**Risk:** Minimal (can revert with git if needed)  
**Estimated Time:** 2 hours  
**Author:** Development Team  
**Date:** 20
